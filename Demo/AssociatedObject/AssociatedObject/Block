
从闭包说起
在Lisp这样的语言中，有一个概念叫做闭包（closure1），指的是一个函数以及它所处的词法作用域（lexical scope2）构成的整体。为了理解闭包，我们首先来看看什么是词法作用域。

所谓词法作用域，顾名思义，是指一个符号引用的是其词法环境中的变量，而无关程序在运行时的状态。这么说可能有点抽象，让我来看一段Common Lisp3代码：

(defvar printer (let ((x 42))
(lambda () (format t "~a" x))))
这里我们定义了一个变量printer，它的值是一个函数，这个函数会打印词法作用域中的变量x（其值为42）。

现在我们来调用这个函数：

CL-USER> (funcall printer)
42
可以看到，我们调用了printer中存放的函数之后，打印出来的数字是42，跟我们的预期相符。

接下来再让我们看一个可能会出乎意料的结果：

CL-USER> (let ((x 1))
(funcall printer))
42
我们在调用之前把x设置为了1，但是打印的结果仍然是42。

为什么？因为printer中存放的函数在被调用时所引用的变量位于其词法作用域中， 即该函数被定义时所处的词法环境中，所以程序在运行时设置的变量x对函数不起作用。

前面我们讲过，所谓闭包，就是函数及其词法作用域的合称，具体到上例，那么匿名函数和x就构成了一个闭包，它会为函数保存一种状态，有点类似于全局变量，不过除了那个匿名函数，其他函数无法访问到x。

说了这么多，似乎跟block毫无关系？事实上，block为C带来了闭包。

